<HTML>



<BODY>    

<div class="ui">
    <div class="controls">
        Area Circle X: <input id="rx" type="number" onchange="UpdateXNumbers(this.value)"/><br><br>
        Area Circle Y: <input id="ry" type="number"  onchange="UpdateYNumbers(this.value)"   disabled="disabled"/><br><br>
		Area    Union: <input id="aUnion" type="number" onchange="UpdateUNumbers(this.value)" disabled="disabled"/><br>
    </div>
    <div class="results">
        Circle X Area: <span style="color:blue" id="AreaXvalue"></span>  Radius: <span style="color:blue" id="RadiusXvalue"></span><br>
        Circle Y Area: <span style="color:blue" id="AreaYvalue"></span>  Radius: <span style="color:blue" id="RadiusYvalue"></span><br>
		Union Area: <span style="color:blue" id="AreaUvalue"></span>  Iterations: <span style="color:blue" id="CircDist"></span><br>
        Circle X Angle: <span style="color:blue" id="AngleXvalue"></span><br>
        Circle Y Angle: <span style="color:blue" id="AngleYvalue"></span><br>
        Starter Union Area: <span style="color:blue" id="StartAreaUvalue"></span><br>
		Test Union Area: <span style="color:blue" id="TestAreaUvalue"></span><br>
    </div>
</div>


  <style>

    path:hover {stroke:black;}
	.ui {
            display: flex;
        }

        .ui > div {
            margin: 0 10px;
        }

        .ui .controls input {
            vertical-align: middle;
			width: 100px;
			height: 20px;
        }
	    .ui .results {
            float: right;
        }
		
        svg {
            background: #ddd;
        }

  </style>

  

  <svg width="700" height="560" xmlns="http://www.w3.org/2000/svg">
    <path id="arc1"  d="" fill="blue" fill-opacity=".5"/>
    <path id="arc2" d="" fill="yellow" fill-opacity=".5"/> 
    <path id="arc3" d="" fill="green" fill-opacity=".5"/> 		 
	
  </svg>

  <script>
    //capture all the element you plan to change
	var EasyPI = Math.round(Math.PI*100000)/100000;
	var RadiusX;
	var RadiusY;
	var RxMin=1;
	var RxMax=4000;
    var RyMin=1;
	var RyMax=4000;
	var AUmin=1;
	var AUmax=4000;
	
	var AreaX=0;
	var AreaY=0;
	var AreaU=0;
	var StartAreaU;
	var TestAreaU=-1;
	var AngleX;
	var AngleY;
	var DistX;
	var DistY;
	var arcDist;
	var AcuteAngle=false;
	var EscapeHatch=0;
	var AngleMove=EasyPI/2;

	
	function UpdateXNumbers(e)
	{
	 AreaX=parseInt(e);
	 if(AreaX>RxMax)
	 {
	  AreaX=RxMax;
	  document.getElementById("rx").value=AreaX;
	 }
	 else if(AreaX<RxMin)
	 {
	  AreaX=RxMin;
	  document.getElementById("rx").value=AreaX;
	 }
	 
	 AreaXvalue.innerHTML=AreaX;
	 //update the Area value if it is greater than the smallest circle 
	 AUmax=AreaX;
	 RyMin=AreaX;
	  //unlock Circle Y input
	  if(ry.disabled)
	  {
	    ry.disabled=false;
	  }
	  else if(AreaY!=0)
	  {
	    DoMathStuff();
	    BuildArcs();
	  }
	 
	} 
		
	function UpdateYNumbers(e)
	{ 
	 AreaY=parseInt(e);
	 if(AreaY>RyMax)
	 {
	  AreaY=RyMax;
	  document.getElementById("ry").value=RyMax;
	 }
	 else if(AreaY<RyMin)
	 {
	  AreaY=RyMin;
	  document.getElementById("ry").value=RyMin;
	 }
	 
	 AreaYvalue.innerHTML=AreaY;
	 //update the Area value if it is greater than the smallest circle 
	 RxMax=AreaY;
	 if(AreaY!=0)
	  {	
	   DoMathStuff();
	   BuildArcs();
	   //unlock Area Input
	   if(aUnion.disabled){aUnion.disabled=false;} 
	  }
	}
	 
	 
	
	function UpdateUNumbers(e)
	{
	 AreaU=parseInt(e);
	 if(AreaU>AUmax)
	 {
	   AreaU=AUmax;
	   document.getElementById("aUnion").value=RyMin;
	 }
	 
	 AreaUvalue.innerHTML=AreaU;
	 //Make sure the user cant make the smallest circle smaller than the union 
	 RxMin=AreaU;
	 DoMathStuff();
	 BuildArcs();
	}
	
	
	function DoMathStuff()
	{
  	   //do math stuff
	   //find the radiuses given the areas
	   RadiusY=Math.round(Math.sqrt(AreaY/EasyPI)*100)/100;
	   RadiusX=Math.round(Math.sqrt(AreaX/EasyPI)*100)/100;
   	   
	   //make the angle of the small circle to the join point 90 degrees
	   AngleX=EasyPI/2;
	   //the distance of the begining arc is 2x the radius of smaller circle
	   arcDist = RadiusX*2;
	   //the distance of the begining small cirle to the join line is 0
	   DistX=0;
	   
	   //find the angle of the large circle to the join point
	   AngleY=Math.asin((arcDist*.5)/(RadiusY));
	   //the distance of the begining Y cirle to the join line 
	   DistY=Math.cos(AngleY)*RadiusY;
       //find the area of the union 
	  // StartAreaU=(AreaX*((AngleX)/(EasyPI))-(DistX*arcDist*.5))+(AreaY*((AngleY)/(EasyPI))-(DistY*arcDist*.5));
	  StartAreaU=AreaX/2+AreaY*AngleY/EasyPI-DistY*RadiusX;
	   if(AreaU!=0)
	   {
	    //is the Area greater than the start area?
		if(AreaU>StartAreaU)
		{
		  AcuteAngle=false;
		   TestAreaU=StartAreaU;
		  //test 135 d	egrees
		  AngleMove=EasyPI/2;
		  EscapeHatch=1;
		  do
		  {
		    EscapeHatch++;
			AngleMove=AngleMove/2;
			if(TestAreaU>AreaU)
			{
		     AngleX=AngleX-AngleMove;
			}
            else
            {
			 AngleX=AngleX+AngleMove;
            } 			
		    arcDist = RadiusX*2*Math.sin(AngleX);
		    DistX=Math.cos(AngleX)*RadiusX;
		    AngleY=Math.asin((arcDist*.5)/(RadiusY));
		    DistY=Math.cos(AngleY)*RadiusY;
		    TestAreaU=(AreaX*((AngleX*2)/(2*EasyPI))-(DistX*arcDist*.5))+(AreaY*((AngleY*2)/(2*EasyPI))-(DistY*arcDist*.5));
		    TestAreaU=Math.round(TestAreaU);
		  }
           while((AreaU!=TestAreaU)&&EscapeHatch<20);  		  
		}
		else if(AreaU<StartAreaU)
		{
		  AcuteAngle=true;
		  TestAreaU=StartAreaU;
		  //test 45 degrees
		  AngleMove=EasyPI/2;
		  EscapeHatch=1;
          do
          {		  
		    EscapeHatch++;
			AngleMove=AngleMove/2;
			if(TestAreaU>AreaU)
			{
		     AngleX=AngleX-AngleMove;
			}
            else
            {
			 AngleX=AngleX+AngleMove;
            } 			
		    arcDist = RadiusX*2*Math.sin(AngleX);
		    DistX=Math.cos(AngleX)*RadiusX;
		    AngleY=Math.asin((arcDist*.5)/(RadiusY));
		    DistY=Math.cos(AngleY)*RadiusY;
		    TestAreaU=(AreaX*((AngleX*2)/(2*EasyPI))-(DistX*arcDist*.5))+(AreaY*((AngleY*2)/(2*EasyPI))-(DistY*arcDist*.5));
		    TestAreaU=Math.round(TestAreaU);
		  } 
		  while((AreaU!=TestAreaU)&&EscapeHatch<20); 
		}
	   }
       	   
		
	 //show results
	 RadiusYvalue.innerHTML=RadiusY;
	 RadiusXvalue.innerHTML=RadiusX;
	 AngleXvalue.innerHTML=Math.round(AngleX*100000)/100000;
	 AngleYvalue.innerHTML=Math.round(AngleY*100000)/100000;
	 StartAreaUvalue.innerHTML=Math.round(StartAreaU*100000)/100000;
	 TestAreaUvalue.innerHTML=TestAreaU;
	 CircDist.innerHTML=EscapeHatch;
	}
	function BuildArcs()
	{
	   
	  if(AcuteAngle)
	  {
	    var PathArc1Str = "M300,100 a " + RadiusX*5 + "," + RadiusX*5 + ", 0, 1, 0, 0, " + arcDist*5 + "  a " + RadiusY*5 + "," + RadiusY*5 + ", 0, 0, 1, 0, -" + arcDist*5 + " z";
  	    var PathArc2Str = "M300,100 a " + RadiusY*5 + "," + RadiusY*5 + ", 0, 1, 1, 0, " + arcDist*5 + "  a " + RadiusX*5 + "," + RadiusX*5 + ", 0, 0, 0, 0, -" + arcDist*5 + " z";
	    var PathArc3Str = "M300,100 a " + RadiusY*5 + "," + RadiusY*5 + ", 0, 0, 0, 0, " + arcDist*5 + "  a " + RadiusX*5 + "," + RadiusX*5 + ", 0, 0, 0, 0, -" + arcDist*5 + " z";
	  }
	  else
	  {
	    var PathArc1Str = "M300,100 a " + RadiusX*5 + "," + RadiusX*5 + ", 0, 0, 0, 0, " + arcDist*5 + "  a " + RadiusY*5 + "," + RadiusY*5 + ", 0, 0, 1, 0, -" + arcDist*5 + " z";
	    var PathArc2Str = "M300,100 a " + RadiusY*5 + "," + RadiusY*5 + ", 0, 1, 1, 0, " + arcDist*5 + "  a " + RadiusX*5 + "," + RadiusX*5 + ", 0, 1, 0, 0, -" + arcDist*5 + " z";
	    var PathArc3Str = "M300,100 a " + RadiusY*5 + "," + RadiusY*5 + ", 0, 0, 0, 0, " + arcDist*5 + "  a " + RadiusX*5 + "," + RadiusX*5 + ", 0, 1, 0, 0, -" + arcDist*5 + " z";
	  }
	  
	  	  
	  arc1.setAttribute("d",PathArc1Str);
	  arc2.setAttribute("d",PathArc2Str);
	  arc3.setAttribute("d",PathArc3Str);
	  
	  
	  
	}


  </script>

  </BODY>

</HTML>  